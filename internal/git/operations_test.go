/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestNewOperations(t *testing.T) {
	authConfig := AuthConfig{
		Type:     AuthTypeNone,
		Username: "test-user",
		Password: "test-pass",
	}

	ops := NewOperations("/tmp/test", authConfig)

	if ops.workingDir != "/tmp/test" {
		t.Errorf("Expected working dir '/tmp/test', got '%s'", ops.workingDir)
	}

	if ops.authorName != "Image Resource Controller" {
		t.Errorf("Expected default author name 'Image Resource Controller', got '%s'", ops.authorName)
	}

	if ops.authorEmail != "image-controller@example.com" {
		t.Errorf("Expected default author email 'image-controller@example.com', got '%s'", ops.authorEmail)
	}
}

func TestSetAuthor(t *testing.T) {
	ops := NewOperations("", AuthConfig{Type: AuthTypeNone})

	ops.SetAuthor("Test User", "test@example.com")

	if ops.authorName != "Test User" {
		t.Errorf("Expected author name 'Test User', got '%s'", ops.authorName)
	}

	if ops.authorEmail != "test@example.com" {
		t.Errorf("Expected author email 'test@example.com', got '%s'", ops.authorEmail)
	}
}

func TestSetupAuth(t *testing.T) {
	tests := []struct {
		name        string
		authConfig  AuthConfig
		expectError bool
	}{
		{
			name: "None auth",
			authConfig: AuthConfig{
				Type: AuthTypeNone,
			},
			expectError: false,
		},
		{
			name: "HTTP auth with username/password",
			authConfig: AuthConfig{
				Type:     AuthTypeHTTP,
				Username: "user",
				Password: "pass",
			},
			expectError: false,
		},
		{
			name: "GitHub token auth",
			authConfig: AuthConfig{
				Type:  AuthTypeGitHubToken,
				Token: "ghp_token123",
			},
			expectError: false,
		},
		{
			name: "GitLab token auth",
			authConfig: AuthConfig{
				Type:  AuthTypeGitLabToken,
				Token: "glpat-token123",
			},
			expectError: false,
		},
		{
			name: "HTTP auth missing credentials",
			authConfig: AuthConfig{
				Type: AuthTypeHTTP,
			},
			expectError: true,
		},
		{
			name: "SSH auth missing key",
			authConfig: AuthConfig{
				Type: AuthTypeSSH,
			},
			expectError: true,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			ops := NewOperations("", test.authConfig)
			err := ops.setupAuth()

			if test.expectError && err == nil {
				t.Error("Expected error but got none")
			}
			if !test.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}
		})
	}
}

func TestGenerateCommitMessage(t *testing.T) {
	tests := []struct {
		name      string
		imageName string
		imageTag  string
		operation string
		expected  string
	}{
		{
			name:      "Create operation",
			imageName: "nginx",
			imageTag:  "v1.0.0",
			operation: "create",
			expected:  "feat: Add Kubernetes resources for nginx:v1.0.0",
		},
		{
			name:      "Update operation",
			imageName: "redis",
			imageTag:  "v2.0.0",
			operation: "update",
			expected:  "chore: Update redis to v2.0.0",
		},
		{
			name:      "Default operation",
			imageName: "mysql",
			imageTag:  "v3.0.0",
			operation: "deploy",
			expected:  "chore: Automated update for mysql:v3.0.0",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			message := GenerateCommitMessage(test.imageName, test.imageTag, test.operation)

			if !strings.Contains(message, test.expected) {
				t.Errorf("Expected message to contain '%s', got '%s'", test.expected, message)
			}

			// Check that it contains timestamp
			if !strings.Contains(message, "Timestamp:") {
				t.Error("Expected message to contain timestamp")
			}

			// Check that it contains controller signature
			if !strings.Contains(message, "Generated by Image Resource Controller") {
				t.Error("Expected message to contain controller signature")
			}
		})
	}
}

func TestWriteFiles(t *testing.T) {
	// Create temporary directory
	tempDir, err := os.MkdirTemp("", "git-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	ops := NewOperations(tempDir, AuthConfig{Type: AuthTypeNone})

	files := map[string]string{
		"test.yaml":          "apiVersion: v1\nkind: ConfigMap",
		"subdir/nested.yaml": "apiVersion: apps/v1\nkind: Deployment",
		"another/file.txt":   "Simple text content",
	}

	changedFiles, err := ops.writeFiles(files)
	if err != nil {
		t.Fatalf("writeFiles failed: %v", err)
	}

	// Check that all files were returned as changed
	if len(changedFiles) != len(files) {
		t.Errorf("Expected %d changed files, got %d", len(files), len(changedFiles))
	}

	// Verify files were actually written
	for filename, expectedContent := range files {
		fullPath := filepath.Join(tempDir, filename)

		// Check file exists
		if _, err := os.Stat(fullPath); os.IsNotExist(err) {
			t.Errorf("File %s was not created", filename)
			continue
		}

		// Check file content
		content, err := os.ReadFile(fullPath)
		if err != nil {
			t.Errorf("Failed to read file %s: %v", filename, err)
			continue
		}

		if string(content) != expectedContent {
			t.Errorf("File %s content mismatch. Expected '%s', got '%s'",
				filename, expectedContent, string(content))
		}
	}

	// Check that directories were created
	subdirPath := filepath.Join(tempDir, "subdir")
	if _, err := os.Stat(subdirPath); os.IsNotExist(err) {
		t.Error("Subdirectory 'subdir' was not created")
	}

	anotherDirPath := filepath.Join(tempDir, "another")
	if _, err := os.Stat(anotherDirPath); os.IsNotExist(err) {
		t.Error("Subdirectory 'another' was not created")
	}
}

func TestCleanup(t *testing.T) {
	// Create temp directory that should be cleaned up
	tempDir, err := os.MkdirTemp("", "git-operations-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	ops := NewOperations(tempDir, AuthConfig{Type: AuthTypeNone})

	// Verify directory exists
	if _, err := os.Stat(tempDir); os.IsNotExist(err) {
		t.Fatal("Temp directory should exist")
	}

	// Cleanup
	err = ops.Cleanup()
	if err != nil {
		t.Errorf("Cleanup failed: %v", err)
	}

	// Verify directory was removed
	if _, err := os.Stat(tempDir); !os.IsNotExist(err) {
		t.Error("Temp directory should have been removed")
	}
}

func TestCleanupNonTempDir(t *testing.T) {
	// Test with non-temp directory (should not be cleaned up)
	ops := NewOperations("/some/permanent/dir", AuthConfig{Type: AuthTypeNone})

	err := ops.Cleanup()
	if err != nil {
		t.Errorf("Cleanup should not fail for non-temp dirs: %v", err)
	}
	// We can't verify the directory wasn't removed since it doesn't exist,
	// but the function should not attempt to remove non-temp directories
}

// Integration test that would require actual Git repository
// This test is skipped by default but can be enabled for integration testing
func TestCloneAndCommitFilesIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// This would require a real Git repository URL and valid credentials
	// For now, we'll test the error handling with invalid URL
	ops := NewOperations("", AuthConfig{Type: AuthTypeNone})

	files := map[string]string{
		"test.yaml": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: test",
	}

	result, err := ops.CloneAndCommitFiles(
		context.TODO(),
		"https://invalid-repo-url.com/repo.git",
		"main",
		files,
		"Test commit",
	)

	// Should fail due to invalid URL
	if err == nil {
		t.Error("Expected error for invalid repository URL")
	}

	if result.Success {
		t.Error("Expected operation to fail")
	}

	if result.Error == "" {
		t.Error("Expected error message to be set")
	}
}

func TestOperationResult(t *testing.T) {
	// Test OperationResult structure
	commitInfo := CommitInfo{
		Hash:      "abc123",
		Message:   "Test commit",
		Author:    "Test Author",
		Email:     "test@example.com",
		Timestamp: time.Now(),
		Files:     []string{"test.yaml"},
	}

	result := OperationResult{
		Success:      true,
		CommitInfo:   commitInfo,
		WorkingDir:   "/tmp/test",
		RemoteURL:    "https://github.com/test/repo.git",
		Branch:       "main",
		FilesChanged: 1,
	}

	if !result.Success {
		t.Error("Expected success to be true")
	}

	if result.CommitInfo.Hash != "abc123" {
		t.Errorf("Expected commit hash 'abc123', got '%s'", result.CommitInfo.Hash)
	}

	if result.FilesChanged != 1 {
		t.Errorf("Expected 1 file changed, got %d", result.FilesChanged)
	}
}

func TestOperationStats(t *testing.T) {
	// Test OperationStats structure
	stats := OperationStats{
		TotalOperations:   10,
		SuccessfulOps:     8,
		FailedOps:         2,
		AverageCommitSize: 5,
		LastOperation:     time.Now(),
		TotalFilesChanged: 50,
	}

	if stats.TotalOperations != stats.SuccessfulOps+stats.FailedOps {
		t.Error("Total operations should equal successful + failed operations")
	}

	if stats.TotalOperations != 10 {
		t.Errorf("Expected 10 total operations, got %d", stats.TotalOperations)
	}
}

func TestAuthConfigValidation(t *testing.T) {
	tests := []struct {
		name   string
		config AuthConfig
		valid  bool
	}{
		{
			name: "Valid HTTP auth",
			config: AuthConfig{
				Type:     AuthTypeHTTP,
				Username: "user",
				Password: "pass",
			},
			valid: true,
		},
		{
			name: "Valid GitHub token",
			config: AuthConfig{
				Type:  AuthTypeGitHubToken,
				Token: "ghp_token",
			},
			valid: true,
		},
		{
			name: "Valid none auth",
			config: AuthConfig{
				Type: AuthTypeNone,
			},
			valid: true,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			ops := NewOperations("", test.config)
			err := ops.setupAuth()

			if test.valid && err != nil {
				t.Errorf("Expected valid config to not error, got: %v", err)
			}
			if !test.valid && err == nil {
				t.Error("Expected invalid config to error")
			}
		})
	}
}
